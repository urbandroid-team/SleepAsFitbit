import * as tslib_1 from "tslib";
import { EventEmitter } from 'events';
import * as t from 'io-ts';
import { decode, InvalidParams, ParseJSON, Peer, TypesafeRequestDispatcher, } from '@fitbit/jsonrpc-ts';
import { BulkData, FDBTypes, maxBase64DecodedSize, } from '@fitbit/fdb-protocol';
import * as lodash from 'lodash';
import { version } from '../package.json';
import ConfigurableEncode from './ConfigurableEncode';
var RemoteHost = (function (_super) {
    tslib_1.__extends(RemoteHost, _super);
    function RemoteHost(timeout) {
        var _this = _super.call(this) || this;
        _this.dispatcher = new TypesafeRequestDispatcher();
        _this.rpc = new Peer(_this.dispatcher);
        _this.bulkDataStreams = new BulkData();
        _this.screenshotStreams = new Map();
        _this.serializerTransform = new ConfigurableEncode();
        _this.handleMessage = function (params) {
            if (params.timestamp) {
                _this.emit('consoleMessage', tslib_1.__assign({}, params, { timestamp: _this.convertTimestamp(params.timestamp) }));
            }
            else {
                _this.emit('consoleMessage', params);
            }
        };
        _this.handleTrace = function (params) {
            if (params.timestamp) {
                _this.emit('consoleTrace', tslib_1.__assign({}, params, { timestamp: _this.convertTimestamp(params.timestamp) }));
            }
            else {
                _this.emit('consoleTrace', params);
            }
        };
        _this.handleAppRunning = function (params) {
            _this.emit('appRunning', params);
        };
        _this.handleAppClosed = function (params) {
            _this.emit('appClosed', params);
        };
        _this.initialize = _this.bindMethod('initialize', FDBTypes.InitializeParams, FDBTypes.InitializeResult);
        _this.ping = function () { return _this.rpc.callMethod('ping', undefined, { timeout: _this.timeout }); };
        _this.ioWrite = _this.bindMethod('io.write', FDBTypes.IOWriteParams, t.any, { timeoutEnabled: false });
        _this.beginStreamingInstall = _this.bindMethod('app.install.stream.begin', FDBTypes.AppInstallStreamBeginParams, FDBTypes.StreamOpenResponse);
        _this.finalizeStreamingInstall = _this.bindMethod('app.install.stream.finalize', FDBTypes.StreamCloseParams, FDBTypes.AppInstallResult, { minTimeout: 300000 });
        _this.abortStreamingInstall = _this.bindMethod('app.install.stream.abort', FDBTypes.StreamCloseParams, t.any);
        _this.launchAppComponent = _this.bindMethod('app.launchComponent', FDBTypes.LaunchComponentParams, FDBTypes.AppComponent);
        _this.changeSerialization = function (serialization) {
            _this.rpc.sendNotification('protocol.serialization.change', { serialization: serialization });
            _this.serializerTransform.setEncoder(serialization);
        };
        _this.beginStreamingScreenshotCapture = _this.bindMethod('app.screenshot.stream.capture', FDBTypes.AppScreenshotStreamCaptureParams, FDBTypes.AppScreenshotStreamCaptureResult);
        _this.handleScreenshotFinalize = function (_a) {
            var stream = _a.stream;
            var context = _this.popScreenshotContext(stream);
            context.resolve(context.stream.finalize());
        };
        _this.handleScreenshotAbort = function (_a) {
            var stream = _a.stream;
            var context = _this.popScreenshotContext(stream);
            context.stream.finalize();
            context.reject('Aborted by host');
        };
        _this.sendEvalCmd = _this.bindMethod('experimental.debug.eval', FDBTypes.AppDebugEvalParams, FDBTypes.AppDebugEvalResult);
        _this.timeout = timeout;
        _this.dispatcher
            .method('ping', t.undefined, function () { })
            .method('app.screenshot.stream.finalize', FDBTypes.StreamCloseParams, _this.handleScreenshotFinalize)
            .method('app.screenshot.stream.abort', FDBTypes.StreamCloseParams, _this.handleScreenshotAbort)
            .notification('console.message', FDBTypes.ConsoleMessage, _this.handleMessage)
            .notification('console.traceMessage', FDBTypes.TraceMessage, _this.handleTrace)
            .notification('experimental.lifecycle.appRunning', FDBTypes.App, _this.handleAppRunning)
            .notification('experimental.lifecycle.appClosed', FDBTypes.App, _this.handleAppClosed);
        _this.bulkDataStreams.register(_this.dispatcher);
        return _this;
    }
    RemoteHost.connect = function (hostStream, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.userAgentSuffix, userAgentSuffix = _c === void 0 ? '' : _c, _d = _b.timeout, timeout = _d === void 0 ? 10000 : _d;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userAgent, host, reqTime, _e;
            return tslib_1.__generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        userAgent = this.USER_AGENT;
                        if (userAgentSuffix) {
                            userAgent = userAgent + " " + userAgentSuffix;
                        }
                        host = new this(timeout);
                        hostStream
                            .pipe(new ParseJSON)
                            .pipe(host.rpc)
                            .pipe(host.serializerTransform)
                            .pipe(hostStream);
                        reqTime = Date.now();
                        _e = host;
                        return [4, host.initialize({
                                userAgent: userAgent,
                                capabilities: this.CAPABILITIES,
                            })];
                    case 1:
                        _e.info = _f.sent();
                        if (host.hasCapability('protocol.additionalSerializations') &&
                            host.info.capabilities.protocol.additionalSerializations.includes('cbor-definite')) {
                            host.changeSerialization('cbor-definite');
                        }
                        host.epoch = new Date((reqTime + Date.now()) / 2);
                        return [2, host];
                }
            });
        });
    };
    RemoteHost.prototype.convertTimestamp = function (relativeTS) {
        return new Date(this.epoch.getTime() + relativeTS * 1000);
    };
    RemoteHost.prototype.hasCapability = function (path) {
        return lodash.get(this.info.capabilities, path) !== undefined;
    };
    Object.defineProperty(RemoteHost.prototype, "maxMessageSize", {
        get: function () {
            var protocolDefaultSize = 8192;
            var capabilitySize = lodash.get(this.info.capabilities, 'protocol.maxMessageSize', 0);
            return Math.max(protocolDefaultSize, capabilitySize);
        },
        enumerable: true,
        configurable: true
    });
    RemoteHost.prototype.bindMethod = function (method, paramsType, resultType, _a) {
        var _this = this;
        var _b = _a === void 0 ? {} : _a, _c = _b.timeoutEnabled, timeoutEnabled = _c === void 0 ? true : _c, _d = _b.minTimeout, minTimeout = _d === void 0 ? 0 : _d;
        return function (params) {
            return _this.rpc.callMethod(method, params, {
                timeout: timeoutEnabled ? Math.max(_this.timeout, minTimeout) : undefined,
            }).then(decode(resultType));
        };
    };
    RemoteHost.prototype.writeToStream = function (stream, data, _a) {
        var _b = (_a === void 0 ? {} : _a).onProgress, onProgress = _b === void 0 ? (function () { }) : _b;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            var overheadChars, maxDataBytes, expireWriteTimeout, writeTimedOut, timeoutTimer, resetWriteTimeout, writes, _loop_1, this_1, cursor;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        overheadChars = 256;
                        maxDataBytes = maxBase64DecodedSize(this.maxMessageSize - overheadChars);
                        if (maxDataBytes < 1) {
                            throw new Error('Cannot fit any data into an io.write message');
                        }
                        writeTimedOut = new Promise(function (_, reject) {
                            expireWriteTimeout = function () {
                                reject(new Error('io.write timed out'));
                            };
                        });
                        timeoutTimer = setTimeout(expireWriteTimeout, this.timeout);
                        resetWriteTimeout = function () {
                            clearTimeout(timeoutTimer);
                            timeoutTimer = setTimeout(expireWriteTimeout, _this.timeout);
                        };
                        writes = [];
                        _loop_1 = function (cursor) {
                            var chunk = this_1.serializerTransform.canAcceptRawBuffers() ? {
                                stream: stream,
                                data: data.slice(cursor, cursor + maxDataBytes),
                                encoding: 'none',
                            } : {
                                stream: stream,
                                data: data.toString('base64', cursor, cursor + maxDataBytes),
                            };
                            writes.push(this_1.ioWrite(chunk).then(function () {
                                resetWriteTimeout();
                                onProgress(Math.min(cursor + maxDataBytes, data.length), data.length);
                            }));
                        };
                        this_1 = this;
                        for (cursor = 0; cursor < data.length; cursor += maxDataBytes) {
                            _loop_1(cursor);
                        }
                        return [4, Promise.race([Promise.all(writes), writeTimedOut])];
                    case 1:
                        _c.sent();
                        clearTimeout(timeoutTimer);
                        return [2];
                }
            });
        });
    };
    RemoteHost.prototype.installApp = function (componentBundle, data, _a) {
        var _b = (_a === void 0 ? {} : _a).onProgress, onProgress = _b === void 0 ? (function () { }) : _b;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var stream, e_1;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4, this.beginStreamingInstall({ componentBundle: componentBundle })];
                    case 1:
                        stream = (_c.sent()).stream;
                        _c.label = 2;
                    case 2:
                        _c.trys.push([2, 4, , 5]);
                        return [4, this.writeToStream(stream, data, { onProgress: onProgress })];
                    case 3:
                        _c.sent();
                        return [3, 5];
                    case 4:
                        e_1 = _c.sent();
                        this.abortStreamingInstall({ stream: stream });
                        throw e_1;
                    case 5: return [2, this.finalizeStreamingInstall({ stream: stream })];
                }
            });
        });
    };
    RemoteHost.prototype.canTakeScreenshot = function () {
        return (this.hasCapability('appHost.screenshot') &&
            !!this.info.capabilities.appHost.screenshot.stream);
    };
    RemoteHost.prototype.screenshotFormats = function () {
        if (!this.canTakeScreenshot())
            return [];
        return this.info.capabilities.appHost.screenshot.imageFormats;
    };
    RemoteHost.prototype.takeScreenshot = function (format, onWrite) {
        var _this = this;
        var stream = this.bulkDataStreams.createWriteStream();
        return new Promise(function (resolve, reject) {
            _this.beginStreamingScreenshotCapture({ stream: stream.token, imageFormat: format })
                .then(function (_a) {
                var length = _a.length;
                if (onWrite) {
                    stream.onWrite = function (_, received) { return onWrite(received, length); };
                }
                _this.screenshotStreams.set(stream.token, { stream: stream, resolve: resolve, reject: reject });
            })
                .catch(function (reason) {
                stream.finalize();
                reject(reason);
            });
        });
    };
    RemoteHost.prototype.popScreenshotContext = function (token) {
        var context = this.screenshotStreams.get(token);
        if (context !== undefined) {
            this.screenshotStreams.delete(token);
            return context;
        }
        throw new InvalidParams('Stream token does not match any open screenshot stream', { stream: token });
    };
    RemoteHost.prototype.hasEvalSupport = function () {
        return this.hasCapability('experimental.debug.eval');
    };
    RemoteHost.prototype.eval = function (cmd) {
        return this.sendEvalCmd({ cmd: cmd });
    };
    RemoteHost.CAPABILITIES = {
        protocol: { maxMessageSize: 1024 * 1024 },
        console: { appLogging: true },
        io: { write: true },
    };
    RemoteHost.USER_AGENT = "fdb-debugger/" + version;
    return RemoteHost;
}(EventEmitter));
export { RemoteHost };
