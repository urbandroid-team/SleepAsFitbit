"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const jszip_1 = tslib_1.__importDefault(require("jszip"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const mapValues_1 = tslib_1.__importDefault(require("../util/mapValues"));
function getFile(zip, path) {
    const file = zip.file(path);
    if (!file || file.dir)
        throw new Error(`${path} not present in zip file`);
    return file;
}
async function getBufferFromZip(zip, path) {
    return getFile(zip, path).async('nodebuffer');
}
async function getTextFromZip(zip, path) {
    return getFile(zip, path).async('text');
}
function packageComponentSourceMaps(files, prefix, zip) {
    return lodash_1.default.mapValues(files, (sourceMap, file) => {
        const zipFileName = `sourceMaps/${prefix}/${file}.map`;
        zip.file(zipFileName, JSON.stringify(sourceMap));
        return zipFileName;
    });
}
function bundleSourceMaps(zip, sourceMaps) {
    if (!sourceMaps)
        return;
    const sourceMapObject = { device: {} };
    const packageSourceMaps = (files, prefix) => packageComponentSourceMaps(files, prefix, zip);
    Object.entries(sourceMaps.device).forEach(([family, files]) => {
        sourceMapObject.device[family] = packageSourceMaps(files, `device/${family}`);
    });
    if (sourceMaps.companion) {
        sourceMapObject.companion = packageSourceMaps(sourceMaps.companion, 'companion');
    }
    if (sourceMaps.settings) {
        sourceMapObject.settings = packageSourceMaps(sourceMaps.settings, 'settings');
    }
    return sourceMapObject;
}
const extractComponentSourceMaps = (sourceMapPaths, zip) => mapValues_1.default(sourceMapPaths, path => getTextFromZip(zip, path).then(JSON.parse));
async function extractSourceMaps(zip, sourceMapManifest) {
    if (!sourceMapManifest)
        return undefined;
    const extractComponent = (component) => component && extractComponentSourceMaps(component, zip);
    return {
        device: await mapValues_1.default(sourceMapManifest.device, component => extractComponentSourceMaps(component, zip)),
        companion: await extractComponent(sourceMapManifest.companion),
        settings: await extractComponent(sourceMapManifest.settings),
    };
}
class ManifestParserBase {
    pullMetadata() {
        return {
            buildId: this.manifest.buildId,
            uuid: this.manifest.appId,
            requestedPermissions: this.manifest.requestedPermissions,
        };
    }
    getSDKVersions() {
        const versions = {
            deviceApi: '1.0.0',
        };
        if (this.manifest.components.companion)
            versions.companionApi = '1.0.0';
        return versions;
    }
}
class ManifestParserV5 extends ManifestParserBase {
    constructor(manifest) {
        super();
        this.manifest = manifest;
    }
    getDeviceComponents() {
        if (typeof this.manifest.components !== 'object' || !this.manifest.components.watch) {
            throw new Error('No components listed in manifest.json');
        }
        if (!Array.isArray(this.manifest.platform)) {
            throw new Error('Missing platform descriptors');
        }
        return this.manifest.platform.map((platformDescriptor) => {
            const [, family, platform] = /^([^:]+):?(.+)?$/.exec(platformDescriptor);
            return [
                family.toLowerCase(),
                {
                    platform: platform ? [platform] : undefined,
                    filename: this.manifest.components.watch,
                },
            ];
        });
    }
    getCompanionFilename() {
        return this.manifest.components.companion;
    }
    getSourceMapExtractor() {
        return () => Promise.resolve(undefined);
    }
}
class ManifestParserV6 extends ManifestParserBase {
    constructor(manifest) {
        super();
        this.manifest = manifest;
    }
    getDeviceComponents() {
        if (typeof this.manifest.components !== 'object') {
            throw new Error('No components listed in manifest.json');
        }
        if (!this.manifest.components.watch)
            return [];
        return Object.entries(this.manifest.components.watch);
    }
    getCompanionFilename() {
        return lodash_1.default.get(this.manifest, 'components.companion.filename');
    }
    getSDKVersions() {
        return Object.assign({}, super.getSDKVersions(), this.manifest.sdkVersion);
    }
    getSourceMapExtractor() {
        return (zip) => extractSourceMaps(zip, this.manifest.sourceMaps);
    }
}
function getManifestParser(manifest) {
    switch (manifest.manifestVersion) {
        case 5:
            return new ManifestParserV5(manifest);
        case 6:
            return new ManifestParserV6(manifest);
        default:
            throw new Error(`Unsupported manifest version ${manifest.manifestVersion}`);
    }
}
class AppPackage {
    constructor({ buildId, components, sourceMaps, requestedPermissions, uuid, sdkVersion, }) {
        this.buildId = buildId;
        this.components = components;
        this.sourceMaps = sourceMaps;
        this.requestedPermissions = requestedPermissions;
        this.uuid = uuid;
        this.sdkVersion = sdkVersion;
    }
    generateArtifact() {
        const zip = new jszip_1.default();
        const manifest = {
            manifestVersion: 6,
            buildId: this.buildId,
            appId: this.uuid,
            requestedPermissions: this.requestedPermissions,
            components: { watch: {} },
            sdkVersion: this.sdkVersion,
            sourceMaps: bundleSourceMaps(zip, this.sourceMaps),
        };
        for (const [family, { platform, artifact }] of Object.entries(this.components.device)) {
            const filename = `device-${family}.zip`;
            manifest.components.watch[family] = { platform, filename };
            zip.file(filename, artifact);
        }
        if (this.components.companion) {
            manifest.components.companion = {
                filename: 'companion.zip',
            };
            zip.file(manifest.components.companion.filename, this.components.companion);
        }
        zip.file('manifest.json', JSON.stringify(manifest, null, 2));
        return zip.generateAsync({ type: 'nodebuffer' });
    }
    static async fromArtifact(artifactData) {
        const fbaZip = await jszip_1.default.loadAsync(artifactData);
        const textFile = (path) => getTextFromZip(fbaZip, path);
        const bufferFile = (path) => getBufferFromZip(fbaZip, path);
        const manifestJSON = JSON.parse(await textFile('manifest.json'));
        const parser = getManifestParser(manifestJSON);
        const device = await Promise.all(parser.getDeviceComponents().map(([family, { platform, filename }]) => bufferFile(filename)
            .then(artifact => [family, { platform, artifact }]))).then(lodash_1.default.fromPairs);
        const companionFilename = parser.getCompanionFilename();
        const companion = companionFilename ? await bufferFile(companionFilename) : undefined;
        const sourceMaps = await parser.getSourceMapExtractor()(fbaZip);
        const appPackage = new this(Object.assign({}, parser.pullMetadata(), { sourceMaps, components: {
                device,
                companion,
            }, sdkVersion: parser.getSDKVersions() }));
        appPackage.manifest = manifestJSON;
        return appPackage;
    }
}
exports.default = AppPackage;
